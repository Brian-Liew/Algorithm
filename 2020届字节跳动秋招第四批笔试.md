# 2020届字节跳动秋招第四批笔试

研发岗2019/9/15

#### 第一题：给定一个数组，并给定一个约束值，求出在这个数组中任意三个数的和小于这个约束值的方案有多少种？

例子：

数组大小：6
数组：-2 0 1 2 3 6
约束值：2

输出：4（4种方案）

```c++
/*
字节跳动第四题，但是因为是连续输入的原因导致没能ac
这里也学到了，主要是运用简单的方法就可以解决的；
*/
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	while(cin>>n)
	{
		int array[n];
		for(int i=0;i<n;i++)
			cin>>array[i];
		int D;
		cin>>D;
		sort(array,array+n);
		int sum=0;
		for(int i=0;i<n;i++)
		{
			for(int j=i+1;j<n;j++)
			{
				int temp=array[i]+array[j];
				int num=lower_bound(array+j+1,array+n,D-temp)-(array+j+1);
				sum+=num;
			}
		}
		cout<<sum<<endl;

	}
}
```



#### 第二题：给定一个打印机的流程：首先是总共有几个打印任务数N，然后给出了每一次打印任务的时间点和需要执行的时间长度$t_i$和$lenth_i$，然后要你求出这批打印任务最终的执行时间到多久，同时输出执行过程中出现等候的最长任务数。

例如：

3（个任务）

1 3

2 3

3 3

输出：10   7（因为最后的任务数最多7个，排到3+7=10）

```c++
/*
感觉这道题就是要处理的数据比较多，应该加入一些东西，例如：
std::ios::sync_with_stdio(false);
*/
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
	cin.sync_with_stdio(false);
	int num;
	cin>>num;
	if(num==0)
		return 0;
	//vector<int> test;
	long long cur,task;
	cin>>cur>>task;
	long long max_task=task;
	//test.push_back(task);
	long long cur_next,task_next;
	for(int i=1;i<num;i++)
	{
		cin>>cur_next>>task_next;
		long long minu=min(cur_next-cur,task);
		task=task-minu;
		task=task+task_next;
		if(task>max_task)
			max_task=task;
		cur=cur_next;
	}
	cout<<cur+task<<" "<<max_task<<endl;
}

```



#### 第三题：直接给图：

![zijietiaodong](F:\markdown\zijietiaodong.png)

```c++
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	int nums[n];
	for(int i=0;i<n;i++)
		cin>>nums[i];
	int sum[n];
	int dp[n][n];
	sum[0]=nums[0];
	for(int i=1;i<n;i++)
	{
		sum[i]=sum[i-1]+nums[i];
	}
	for(int i=0;i<n;i++)
	{
		dp[i][i]=nums[i];
	}
	for(int i=n-2;i>=0;i--)
	{
		for(int j=i+1;j<n;j++)
		{
			dp[i][j]=max(sum[j]-sum[i]+nums[i]-dp[i+1][j],sum[j]-sum[i]+nums[i]-dp[i][j-1]);
		}
	}
	
/*	for(int i=1;i<n;i++)
            for(int j=0;i+j<n;j++)
                dp[j][i+j]=max(sum[i+j]-sum[j]+nums[j]-dp[j+1][i+j],sum[i+j]-sum[j]+nums[j]-dp[j][i+j-1]);
*/
	cout<<dp[0][n-1]<<endl;
}

```



#### 第四题：给出商品的总数量，以及你的预算，然后分别给出每个商品的原价、现价，还有它的快乐值，然后规定如果你购买的总的优惠值（原价减去现价）+你的预算>=要购买商品的总价，那么你是可以购买的（心理膨胀），但是你要使得你的快乐值是最高的，求出你能得到的最高快乐值，输入、输出例子：

/*
输入4 100
100 73 60
100 89 35
30 21 30
10 8 10


输出100

输入3 100
100 100 60
80 80 35
21 21 30

输出60

输入2 100
100 30 35
140 140 100

输出135
*/

```c++
#include<iostream>
using namespace std;
int main()
{
	int n,m;
	cin>>n>>m;
	int tol=0;
	int sum=0;
	int a1[500]={0},b1[500]={0},c1[500]={0},dp[500]={0};
	for(int i=0;i<n;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		if(b<=(a-b))
		{
			sum=sum+c;
			m=m+(a-b-b);
		}
		else
		{
			a1[++tol]=a;
			b1[tol]=b-(a-b);
			c1[tol]=c;
		}
	}
	for(int i=1;i<=tol;i++)
	{
		for(int j=m;j>=b1[i];j--)
			dp[j]=max(dp[j],dp[j-b1[i]]+c1[i]);
	}
	cout<<sum+dp[m]<<endl;
}

```

