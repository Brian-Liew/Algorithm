# C++整理

#### 1、C和C++的struct的区别：

|      | 保护 | 可否定义函数       |
| ---- | ---- | ------------------ |
| C    | 无   | 否，但有指针       |
| C++  | 有   | 可以，默认是public |

#### 2、C++中class与struct的区别：

（1）默认继承对于class是private；对于struct是public

（2）成员访问权限：对于class来说默认是private，struct默认是public

#### 3、怎么判断程序时C++编译还是c编译：

#ifdef_cplusplus

cout<<"c++";

#else

printf("c");

#endif

#### 4、c与c++区别：

C是面向过程的结构化编程语言，C++是面向对象的程序语言，一个侧向与过程，一个侧重于类的设计。

#### 5、引用于指针的区别：

引用其实就是对于一个目标变量的别名，对于引用的操作就是对于目标变量的操作；指针通过某个指针指向一个对象后，对它所指向的变量间接操作。

#### 6、某个文件中定义的静态全局变量（静态外部变量）的作用域：

只限制域定义该变量的源文件有效，就算是同一源程序的其他源文件中不能使用它。

#### 7、C++的值传递方式：

值传递、指针传递、引用传递

#### 8、对于一个频繁使用的短小函数，c语言中用什么实现，c++用什么实现：

> c：宏定义；c++：inline
>
> 对于inline：内联函数被放入符号表，使用时直接替换变量，效率很高；但是如果它的代码比较长或者循环多，它又以复制为代价，开销大。
>
> ```markdown
> 我们来看一个例子，比较两个数或者表达式大小，首先我们把它写成宏定义：
> 　　#define MAX( a, b) ( (a) > (b) (a) : (b) )
> 　　其次，把它用函数来实现：
> 　　int max( int a, int b)
> 　　{
> 　　return (a > b a : b)
> 　　}
> 　　很显然，我们不会选择用函数来完成这个任务，原因有两个：首先，函数调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆栈。这种开销不仅会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都比函数更胜一筹；其次，函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用，我们如果要比较两个浮点型的大小，就不得不再写一个专门针对浮点型的比较函数。反之，上面的那个宏定义可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“>”操作符比较值大小的类型，也就是说，宏是与类型无关的。
> 　　和使用函数相比，使用宏的不利之处在于每次使用宏时，一份宏定义代码的拷贝都会插入到程序中。除非宏非常短，否则使用宏会大幅度增加程序的长度。
> ```

#### 9、对于编译工具中，debug和release的含义各是什么

debug为调试版本，通过一系列编译选项配合，不做任何优化，为开发者提供比较强大的应用程序调试能力，release为发布版本，为客户提供优化，达到代码最小以及速度最优。

#### 10、函数assert的使用：

在debug版本中，用于检查不应该发生的情况。

#### 11、const与#define的比较，const的优点：

const常量是有数据类型，而宏常量没有，编译可以对于前者进行安全检查，而对于后者只是字符的替换，没有安全检查，可能出现一些错误。

有些集成的调试工具对于const可以调试，但是对于宏常量不能。

#### 12、const和static的区别：

const定义的常量超出其作用域后空间会被释放，但是static定义的静态变量不会释放存储空间。

总的来说，const就是防止被修改对象，static是使得变量不会被释放空间。

#### 13、有了malloc和free，为什么还要new和delete：

都可以申请动态内存，但是对于非内部数据，前者无法满足动态对象要求，对象在创建同时要自动执行构造函数，对象在消亡前要自动指向析构函数。前者不能指向构造和析构函数，因此无法满足要求。

#### 14、如果申请空间返回NULL，宣告内存申请失败，怎么办？

（1）如果指针是NULL，终止本函数

（2）如果NULL，终止整个程序运行

（3）可以为new设置自己定义的异常处理函数

#### 15、C++是类型安全吗

不是，两个不同类型的指针可以强制转换

#### 16、const的用法：

const char *P：可以改变指向，不可以改变值

char const *P：与上面这个一样

char* const p：const指针，不能改变方向

#### 17、用c++写程序，如何判断是16位还是32位？

sizeof（指针），是4的话就是32位，是2的话就是16位，64位就是8字节

#### 18、用c++，判断16位还是32位系统，不用sizeof：

int a = ~0;

if(a > 65536) {

​    cout<<"32 bit"<<endl;

} else {

​    cout<<"16 bit"<<endl;

}

#### 19、识别函数或指针：

void * ( * (*fp1)(int))[10]; 
float (*(* fp2)(int,int,int))(int);
int (* ( * fp3)())\[10]();

1、void * ( * (*fp1)(int))[10];  fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，
这个数组有10个元素，每个元素是一个void*型指针。
2、float (*(* fp2)(int,int,int))(int);  fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，
这个函数的参数为int型，函数的返回值是float型。
3、int (* ( * fp3)())\[10]();  fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，
这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型

#### 20、多态类中的虚函数是在什么时候进行建立？

虚函数表在编译时就建立，组织成了一个函数入口地址数组，而函数指针则是在运行时进行调用初始化的。

#### 21、内存的分配方式：

一、静态分配：在编译时分配好

二、栈上创建，例如函数，在执行结束时自动释放

三、从堆上分配，就是动态分配

#### 22、判断浮点数是否相等应该怎么办？

应该相减然后看是否小于某一个机器误差

#### 23、堆栈的区别：

栈是系统自动分配的，堆是手动分配，前者空间较小。

#### 24、c++里面的explicit的作用：

防止隐式转换，必须显示声明并且定义。

#### 25、重载和重写，重定义什么区别：

重载时对于同一名字空间，然后函数的参数表不一样，就像默认构造函数，含参数构造函数，拷贝赋值函数；

重写是不同的名字空间，例如多态的虚函数；

重定义：不同于多态的重新写同名字的函数

#### 26、对于一个类中没有声明任何成员，sizeof（A）的大小是多少？

1

#### 27、内联函数相比于宏定义会使用类型检查，是优势

#### 28、函数模板与类模板的区别是什么：

函数由编译程序在处理函数是自动完成，类模板需要程序员显示制定。

#### 29、c++中的static的作用：

在C++类的成员变量被声明为 static（称为静态成员变量），意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，
也就是说不管创建多少对象，static修饰的变量只占有一块内存。其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。static是加了访问控制的全局变量，不被继承。

#### 30、类中使用const的作用：

当它修饰某些常量，只在类中有效，相比于#define是全局的，

当修饰数据成员只能在对象生存周期是常量，超过就可变

const数据成员只能在类中构造函数初始化

#### 31、不能重载的符号：

.、#、@、$

#### 32、基类的析构函数不是虚函数，会怎么样？

使得派生类的析构函数用不上，可能会造成资源泄露。

#### 33、各种变量的内存分配方式：

在函数体中定义的变量——栈

malloc——自由存储区、new——堆

函数体外的全局量、加了static——全局（静态）区（只在文件中有效）

函数体内定义的static只在函数体内有效

#### 34、union的介绍：

union变量所占用到的内存长度等于最长的成员内存长度（所有成员地址一样）

union的作用：用于测试CPU大小端：

```c++
#include <iostream>
using namespace std;

void checkCPU()
{
    union MyUnion{
        int a;
        char c;
    }test;
    test.a = 1;
    if (test.c == 1)
        cout << "little endian" <<endl;
    else cout << "big endian" <<endl;
}

int main()
{
    checkCPU();
    return 0;
}
```

#### 35、变量大小：

64位：

char：1字节；  char*：8字节；  int：4字节；  float：4字节；  double：8字节

long： 8字节； long long：8字节

32位：

char：1字节；  char*：4字节；  int：4字节；  float：4字节；  double：8字节

long：4字节；   long long ：8字节

16位：

char*： 2字节；int：2字节

对于结构体：

在默认对齐方式下，结构体成员的内存分配满足下面三个条件

1. 结构体第一个成员的地址和结构体的首地址相同

2. 结构体每个成员地址相对于结构体首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节（internal adding）。

3. 结构体总的大小要是其成员中最大size的整数倍，如果不是编译器会在其末尾添加填充字节（trailing padding）。

   ### 指定对齐方式

   可以使用#pragma pack(N)来指定结构体成员的对齐方式
   对于指定的对齐方式，其成员的地址偏移以及结构的总的大小也有下面三个约束条件

   1. 结构体第一个成员的地址和结构体的首地址相同
   2. 结构体每个成员的地址偏移需要满足：N大于等于该成员的大小，那么该成员的地址偏移需满足默认对齐方式（地址偏移是其成员大小的整数倍）；Ｎ小于该成员的大小，那么该成员的地址偏移是**N的整数倍**。
   3. 结构体总的大小需要时N的整数倍，如果不是需要在结构体的末尾进行填充。
   4. **如果N大于结构体成员中最大成员的大小，则N不起作用，仍然按照默认方式对齐。**